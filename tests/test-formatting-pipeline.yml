# Test pipeline for formatting functionality
# This file contains various scenarios to test comment preservation, step spacing, and long line handling

trigger:
  branches:
    include:
    # Main production branch
    - main
    # Development branch for testing  
    - develop
    # Feature branches
    - feature/*
  paths:
    exclude:
    - docs/*
    - README.md
# Build configuration variables
variables:
  buildConfiguration: Release # Release build
  solution: '**/*.sln'
  # Long connection string for testing line preservation
  connectionString: Server=tcp:my-very-long-database-server-name.database.windows.net,1433;Initial Catalog=MyApplicationDatabase;Persist Security Info=False;User ID=$(dbUser);Password=$(dbPassword);MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
stages:
# Build stage with multiple jobs
- stage: Build
  displayName: Build and Test Stage
  jobs:
  # Main build job
  - job: BuildJob
    displayName: Build Application
    pool:
      vmImage: ubuntu-latest
    steps:
    # Install .NET SDK
    - task: UseDotNet@2
      displayName: Install .NET Core SDK
      inputs:
        packageType: sdk
        version: 8.x
        installationPath: $(Agent.ToolsDirectory)/dotnet
    # Restore NuGet packages
    - task: DotNetCoreCLI@2
      displayName: Restore NuGet Packages
      inputs:
        command: restore
        projects: $(solution)
        feedsToUse: select
        vstsFeed: my-feed
    # Build the solution
    - task: DotNetCoreCLI@2
      displayName: Build Solution
      inputs:
        command: build
        projects: $(solution)
        arguments: --configuration $(buildConfiguration) --no-restore --verbosity detailed
    # Run unit tests with long command line
    - bash: |
        echo "Running comprehensive test suite with coverage analysis..."
        dotnet test $(solution) --configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage" --results-directory TestResults/ --settings coverlet.runsettings --verbosity normal
        echo "Test execution completed successfully"
      displayName: Run Unit Tests with Coverage
      continueOnError: false
    # Python script with complex logic
    - task: PythonScript@0
      displayName: Generate Test Report
      inputs:
        scriptSource: inline
        script: |
          import json
          import os
          import xml.etree.ElementTree as ET
          from datetime import datetime
          def process_test_results(results_directory, output_file):
              """Process test results and generate comprehensive report with detailed metrics and analysis."""
              test_files = [f for f in os.listdir(results_directory) if f.endswith('.trx')]
              total_tests = 0
              passed_tests = 0
              failed_tests = 0
              for test_file in test_files:
                  file_path = os.path.join(results_directory, test_file)
                  tree = ET.parse(file_path)
                  root = tree.getroot()
                  # Extract test results with detailed parsing for comprehensive analysis
                  for test_result in root.findall('.//UnitTestResult'):
                      total_tests += 1
                      if test_result.get('outcome') == 'Passed':
                          passed_tests += 1
                      else:
                          failed_tests += 1
              report = {
                  'timestamp': datetime.now().isoformat(),
                  'total_tests': total_tests,
                  'passed_tests': passed_tests,
                  'failed_tests': failed_tests,
                  'success_rate': (passed_tests / total_tests * 100) if total_tests > 0 else 0
              }
              with open(output_file, 'w') as f:
                  json.dump(report, f, indent=2)
          process_test_results('TestResults', 'test-report.json')
    # PowerShell deployment preparation
    - powershell: |
        Write-Host "Preparing deployment package with comprehensive validation and security checks..."
        $packagePath = "$(Build.ArtifactStagingDirectory)/deployment-package"
        $configFile = "$packagePath/appsettings.production.json"
        # Create deployment configuration with environment-specific settings and security parameters
        $config = @{
            "ConnectionStrings" = @{
                "DefaultConnection" = "$(connectionString)"
                "RedisCache" = "$(redisCacheConnection)"
            }
            "Logging" = @{
                "LogLevel" = @{
                    "Default" = "Information"
                    "Microsoft" = "Warning"
                }
            }
            "ApplicationInsights" = @{
                "InstrumentationKey" = "$(appInsightsKey)"
            }
        } | ConvertTo-Json -Depth 10
        New-Item -Path $packagePath -ItemType Directory -Force
        Set-Content -Path $configFile -Value $config
        Write-Host "Deployment package prepared successfully at: $packagePath"
      displayName: Prepare Deployment Package
    # Publish build artifacts
    - task: PublishBuildArtifacts@1
      displayName: Publish Build Artifacts
      inputs:
        PathtoPublish: $(Build.ArtifactStagingDirectory)
        ArtifactName: application-build-artifacts-for-deployment
        publishLocation: Container

# Deploy stage with conditional execution
- stage: Deploy
  displayName: Deploy to Production
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  # Deployment job with approval gates
  - deployment: DeployToProduction
    displayName: Deploy Application to Production Environment
    pool:
      vmImage: ubuntu-latest
    environment: production-environment
    strategy:
      runOnce:
        deploy:
          steps:
          # Download build artifacts
          - download: current
            artifact: application-build-artifacts-for-deployment
            displayName: Download Build Artifacts
          # Deploy to Azure Web App
          - task: AzureWebApp@1
            displayName: Deploy to Azure Web App
            inputs:
              azureSubscription: production-azure-service-connection
              appType: webAppLinux
              appName: $(productionWebAppName)
              package: $(Pipeline.Workspace)/application-build-artifacts-for-deployment/*.zip
              runtimeStack: DOTNETCORE
              startUpCommand: dotnet MyApplication.dll
          # Run post-deployment health checks
          - bash: |
              echo "Running comprehensive post-deployment health checks and validation tests..."
              # Wait for application to start
              sleep 30
              # Test application endpoints with retry logic and detailed logging
              for endpoint in "/health" "/api/status" "/api/version"; do
                  echo "Testing endpoint: https://$(productionWebAppName).azurewebsites.net$endpoint"
                  for i in {1..5}; do
                      response=$(curl -s -o /dev/null -w "%{http_code}" "https://$(productionWebAppName).azurewebsites.net$endpoint")
                      if [ "$response" = "200" ]; then
                          echo "✅ Endpoint $endpoint is healthy (HTTP $response)"
                          break
                      else
                          echo "⚠️  Attempt $i: Endpoint $endpoint returned HTTP $response"
                          sleep 10
                      fi
                  done
              done
              echo "Health check validation completed successfully"
            displayName: Post-Deployment Health Checks
            continueOnError: false
